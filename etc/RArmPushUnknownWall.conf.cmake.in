{
    "contact_targets":
    {
      // x/y relative to Left surface, z penetration depth (< 0)
      // x > 0 : higher, y > 0: farther from robot
      "left": [0, 0, -0.01],
      // x/y relative to Right surface, z penetration depth (< 0)
      // x > 0 : higher, y > 0: closer to robot
      "right": [0, 0, -0.01]
    },
    "contact_detection":
    {
	    "UseForceSensor": true, // if true, use the force sensors to detect contact, otherwise use geometric sensor
	    "ForceThreshold": 20.0, // Force threshold that triggers transition. Only used if UseForceSensor is true
	    "ContactThreshold": 1e-5, // Contact distance threshold that triggers transition.
    },
    // Lifting height (m)
    "lift_height": 0.20,
    "push_depth": 0.10,
    // Trajectory task settings
    "trajectory":
    {
      "duration": 6.0,
      "stiffness": 500.0,
      "weight": 500
    },
    // CoM task settings
    "com":
    {
      "type": "com",
      "robotIndex": 0,
      "stiffness": 5.0,
      "weight": 5000
    },
    // FSM settings
    "Managed": false,
    "StepByStep": false,
    "IdleKeepState": true,
    "StatesLibraries": [
        "/usr/local/lib/mc_controller/fsm/states",
        "/usr/local/lib/mc_controller/r_arm_push_unknown_wall/states"
    ],
    "StatesFiles": [
        "/usr/local/lib/mc_controller/fsm/states/data",
        "/usr/local/lib/mc_controller/r_arm_push_unknown_wall/states/data"
    ],
    "robots": {
        "box": {
            "module": "object",
            "params": [
                "${MC_INT_OBJ_DESCRIPTION_PATH}",
                "big_box"
            ]
        },
        "ground":
        {
          "module": "env",
          "params": ["${MC_ENV_DESCRIPTION_PATH}", "ground"]
        }
    },
    "constraints": [
        {
            "type": "contact"
        },
        {
            //"type": "dynamics",
            // arnaud: @yuquan I'm using a kinematic constraint here to generate the impact motion
            // in choreonoid and avoid having the "QP fail to run" due to the robot reaching outside of
            // its support polygon (violation of the DynamicsConstraint)
            // In reality, we should be using DynamicsConstraint here once you have implemented your safe-impact constraints
            "type": "kinematics",
            "robotIndex": 0,
            "damper": [
                0.005,
                0.0005,
                0.5
            ]
        },
        {
            "type": "dynamics",
            "robotIndex": 1
        }
    ],
    "collisions": [
        {
            "type": "collision",
            "r1Index": 0,
            "r2Index": 0,
            "useMinimal": true
        }
    ],
    "contacts": [
        {
            "r1": "hrp4",
            "r2": "ground",
            "r1Surface": "LeftFoot",
            "r2Surface": "AllGround"
        },
        {
            "r1": "hrp4",
            "r2": "ground",
            "r1Surface": "RightFoot",
            "r2Surface": "AllGround"
        },
        {
            "r1": "box",
            "r2": "ground",
            "r1Surface": "Bottom",
            "r2Surface": "AllGround"
        }
    ],
    "hrp4": {
        "posture": {
            "stiffness": 1.0,
            "weight": 10.0
        },
        "ff": {
            "stiffness": 2.0,
            "weight": 100.0
        },
        "leftEfTask": {"bodyName" : "l_wrist", "stiffness" : 20.0, "weight" : 1000.0, "bound" : 0.1 },
        "rightEfTask": {"bodyName" : "r_wrist", "stiffness" : 5.0, "weight" : 200.0, "bound" : 0.1 },
	"rightEfTaskDynamic": {"bodyName" : "r_wrist", "stiffness" : 5.0, "weight" : 200.0, "bound" : 0.1 },
    },
    "impact":{
      "constraints": {
         "jointVelocity": false,
	 "jointTorque": true,
	 "CoPLeft": false,
	 "CoPRight": false,
	 "SlippageLeft": false,
	 "SlippageRight": false,
	 "frictionWithImpulse": true,
	 "copWithImpulse": true,
	 "contactArea": [-0.10, 0.10, -0.05, 0.05],  
	 "zmpWithImpulse": true,
	 "supportPolygon": [-0.07, 0.07, -0.12, 0.12]
	 },
    "estimation":{
	"coeFrictionDeduction": 0.2,
	"coeRestitution": 0.9,
	"delta_dt": 0.005,
	"useLinearJacobian": true,
	"impactBodyName": "r_wrist",
	"end-effectors": [ "l_sole", "r_sole", "l_wrist", "r_wrist"]
         }
    },
    "states": {
      "Prepare":
      {
        "base": "PrepareHand",
        "raiseHandOffset" : [-0.2, 0.0, 0.18],
        "EfThreshold" : 1.0e-1,
      },
      "Contact":
      {
        "base": "DynamicContact", // C++ state
        "contactVelocity" : [0.5, 0.0, 0.0], //
        "pushDepth":  [1.0, 0.0, 0.0], // Target position that should generate the impact 
        // Velocity control for the end-effector
        "rightEfStiffness": 0.0,
        "rightEfDamping": 300.0,
      },
      "Final": { "base": "Pause", "placeholderParameter": 0.1 }
    },
    "transitions": [
        //[ "Pause", "OK", "Prepare", "Auto" ],
        [ "Prepare", "RightHandReady", "Contact", "Auto" ]
        //[ "Contact", "OK", "Final", "Auto" ]
    ]
}
